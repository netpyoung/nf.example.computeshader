{
  "docs/basic/compute_shader.html": {
    "href": "docs/basic/compute_shader.html",
    "title": "컴퓨트셰이더 (ComputeShader) | nf.example.computeshader",
    "summary": "컴퓨트셰이더 (ComputeShader) 등장 일반 렌더링 파이프라인과 별도로 그래픽 카드에서 실행되는 프로그램. 그래픽스와 관련이 없는 환경에서도 GPU의 성능을 활용할 수 있는 API 필요 GPGPU API등장 (General-purpose computing on graphics processing units) GPGPU API OpenCL Khronos Group CUDA C Nvidia DirectCompute Microsoft Platform Graphic Library Windows OpenGL 4.3 / Vulkan / DirectX 11,12, / Shader Model 5.0 Linux OpenGL 4.3 / Vulkan macOS Metal Android OpenGL ES 3.1 / Vulkan iOS Metal 렌더 파이프라인 독립 VS > HS > DS > GS > PS Compute Shader"
  },
  "docs/basic/core_concept.html": {
    "href": "docs/basic/core_concept.html",
    "title": "기본 개념 | nf.example.computeshader",
    "summary": "기본 개념 Kernel / Group / Thread Kernel <--- 작업 단위 | ------------------- | | | Group 0 Group 1 Group 2 <--- 그룹 (SV_GroupID) | | | [T T T] [T T T] [T T T] <--- 쓰레드 (SV_GroupThreadID) 용어 내용 예) Kernel GPU에서 실행되는 컴퓨트 셰이더 함수(작업의 단위) #pragma kernel 함수이름 Group 쓰레드의 그룹. 동시 쓰레드 실행 .Dispatch Thread Kernel이 실행될 때 생성되는 하나의 실행 단위 [numthreads(8, 8, 1)] SV_GroupID .Dispatch(3, 2, 1) SV_GroupThreadID [numthreads(2, 2, 1)] SV_DispatchThreadID SV_GroupID * numthreads + SV_GroupThreadID SV_GroupIndex [0, (numthreadsX * numthreadsY * numThreadsZ) – 1] /// ==================== /// a.cs /// ==================== ComputeShader _computeShader; int kernelIndex = _computeShader.FindKernel(\"Func_KernelIndex_0\"); // 0 int threadGroupsX = 3; int threadGroupsY = 2; int threadGroupsZ = 1; _computeShader.Dispatch(kernelIndex, threadGroupsX, threadGroupsY, threadGroupsZ); // 쓰레드 그룹 6개(3x2x1) // 총 스레드 수 // = 그룹 갯수 * 그룹당 쓰레드 갯수 // = .Dispatch(x, y, z) * numthreads(x, y, z) // = 3x2x1 * 2x2x1 = 6*4 = 24 /// ==================== /// a.compute /// ==================== #pragma kernel Func_KernelIndex_0 #pragma kernel Func_KernelIndex_1 [numthreads(2, 2, 1)] // 그룹당 4쓰레드(2x2x1 ) void Func_KernelIndex_0() uint3 groupID : SV_GroupID uint3 threadID : SV_GroupThreadID uint3 dispatchID : SV_DispatchThreadID uint groupIndex : SV_GroupIndex // SV_DispatchThreadID == SV_GroupID * numthreads + GroupThreadID // dispatchID == groupID * uint3(2, 2, 1) + threadID; // SV_GroupIndex == SV_GroupThreadID.z * numthreads.x * numthreads.y // + SV_GroupThreadID.y * numthreads.x // + SV_GroupThreadID.x // groupIndex == threadID.z * 2 * 2 // + threadID.y * 2 // + threadID.x; uint index = dispatchID.x + dispatchID.y * 6; _Buffer[index] = index; // 0 1 2 3 4 5 // 6 7 8 9 10 11 // 12 13 14 15 16 17 // 18 19 20 21 22 23 _Buffer[index] = groupID.x; | _Buffer[index] = groupID.y; // 0 0 1 1 2 2 | 0 0 0 0 0 0 // 0 0 1 1 2 2 | 0 0 0 0 0 0 // 0 0 1 1 2 2 | 1 1 1 1 1 1 // 0 0 1 1 2 2 | 1 1 1 1 1 1 _Buffer[index] = threadID.x; | _Buffer[index] = threadID.y; // 0 1 0 1 0 1 | 0 0 0 0 0 0 // 0 1 0 1 0 1 | 1 1 1 1 1 1 // 0 1 0 1 0 1 | 0 0 0 0 0 0 // 0 1 0 1 0 1 | 1 1 1 1 1 1 _Buffer[index] = dispatchID.x;| _Buffer[index] = dispatchID.y // 0 1 2 3 4 5 | 0 0 0 0 0 0 // 0 1 2 3 4 5 | 1 1 1 1 1 1 // 0 1 2 3 4 5 | 2 2 2 2 2 2 // 0 1 2 3 4 5 | 3 3 3 3 3 3 _Buffer[index] = groupIndex; // 0 1 0 1 0 1 // 2 3 2 3 2 3 // 0 1 0 1 0 1 // 2 3 2 3 2 3"
  },
  "docs/basic/wip_TODO.html": {
    "href": "docs/basic/wip_TODO.html",
    "title": "| nf.example.computeshader",
    "summary": "HelloWorld #pragma kernel CSMain RWTexture2D<float4> Result; [numthreads(8,8,1)] void CSMain (uint3 id : SV_DispatchThreadID) { Result[id.xy] = float4(1, 0, 0, 1); } RenderTexture renderTexture; Material material; ComputeShader shader; // Shader Model 5.0 level pixel or compute shaders can write into arbitrary locations of some textures, called \"unordered access views\" in UsingDX11GL3Features renderTexture.enableRandomWrite = true; // Universal's Unlit using `_BaseMap` as Main Texture. material.SetTexture(\"_MainTex\", renderTexture); // .compute: #pragma kernel CSMain int kernelHandle = shader.FindKernel(\"CSMain\"); // .compute: RWTexture2D<float4> Result; shader.SetTexture(kernelHandle, \"Result\", renderTexture); // .cs shader.Dispatch(KernelHandle, 3, 2, 1); // .compute [numthreads(4, 4, 1)] void CSMain (uint3 id : SV_DispatchThreadID) // [total] // (3 * 2 * 1) * (4 * 4 * 1) = 96 threads. new RenderTexture(width: 256, height: 256, depth: 0); // 256 x 256 // (0, 256) (256, 256) // +-------+ // | . | // | . | // +-------+ // (0, 0) (256, 0) // GroupID // Dispatch(int kernelIndex, int threadGroupsX, int threadGroupsY, int threadGroupsZ); shader.Dispatch(kernelHandle, 256 / 8, 256 / 8, 1); shader.Dispatch(kernelHandle, 256 / 16, 256 / 16, 1); // 32 * 32 * 1 | 256 / 8 = 32 // 16 * 16 * 1 | 256 / 16 = 16 // ThreadID [numthreads(8, 8, 1)] void CSMain (uint3 id : SV_DispatchThreadID) // 8 * 8 * 1 // DispatchedThreadID // 32 * 8 = 256 | ThreadGroup * NumThreads // 16 * 8 = 128 | ThreadGroup * NumThreads // (0, 256) (256, 256) // +-------+ // | . | // | . | // +-------+ // (0, 0) (256, 0) // // (0, 128) (128, 128) // +---+ // | | // +---+ // (0, 0) (128, 0) // // (32 * 32 * 1) * (8 * 8 * 1) = 65536 // (16 * 16 * 1) * (8 * 8 * 1) = 16384 Buffer 구조체 넘길때 사용 StructuredBuffer<T> 읽기 가능 RWStructuredBuffer<T> 읽기/쓰기 가능 AppendStructuredBuffer<T> push ComputeBufferType.Append ComsumeStructuredBuffer<T> pop GraphicsBuffer.Target ComputeBufferType Raw can be used as a raw byte-address buffer. O O Append can be used as an append-consume buffer. O O Counter with an internal counter. O O Constant can be used as a constant buffer (uniform buffer). O O Structured can be used as a structured buffer. O O IndirectArguments can be used as an indirect argument buffer for indirect draws and dispatches. O O - - - - CopySource can be used as a source for CopyBuffer. O X CopyDestination can be used as a destination for CopyBuffer. O X Index can be used as an index buffer. O X Vertex can be used as a vertex buffer. O X SRP cmd.Blit(_CameraSource, _Source); // BaD // _feature.shader.Dispatch(_handleKernel, _groupSize.x, _groupSize.y, 1); // Good cmd.DispatchCompute(_feature.shader, _handleKernel, _groupSize.x, _groupSize.y, 1); cmd.Blit(_Output, _CameraSource); // Bad - gamma // textureToMake = new RenderTexture( // _texSize.x / divide, // _texSize.y / divide, // 0) // { // enableRandomWrite = true // }; // textureToMake.Create(); // Good - linear textureToMake = new RenderTexture( _texSize.x / divide, _texSize.y / divide, 0, format: RenderTextureFormat.ARGB32, readWrite: RenderTextureReadWrite.Linear) { enableRandomWrite = true }; textureToMake.Create(); Shared // shared #pragma kernel CS_1 #pragma kernel CS_2 shared Texture2D<float4> _Source; shared RWTexture2D<float4> _Output; StructuredBuffer<Particle> _ParticleBuffer; struct VStoFS { float4 positionNDC : SV_POSITION; float psize : PSIZE; } // vertexID // point : 0 // triangle : [0, 1, 2] VStoFS vert(uint vertexID : SV_VertexID, uint instanceID : SV_InstanceID) { Particle p = _ParticleBuffer[instanceID]; }"
  },
  "docs/index.html": {
    "href": "docs/index.html",
    "title": "nf.example.computeshader | nf.example.computeshader",
    "summary": "nf.example.computeshader 문서 소스"
  },
  "docs/ref.html": {
    "href": "docs/ref.html",
    "title": "Ref | nf.example.computeshader",
    "summary": "Ref ScrawkBlog - 링크깨짐 https://github.com/Scrawk DirectCompute tutorial for Unity DirectCompute tutorial for Unity: Introduction DirectCompute tutorial for Unity: Kernels and thread groups DirectCompute tutorial for Unity: Textures DirectCompute tutorial for Unity: Buffers DirectCompute tutorial for Unity: Append buffers DirectCompute tutorial for Unity: Consume buffers 한글번역 by diskhkme 1 / 2 / 3 / 4 / 5 / 6 https://docs.unity3d.com/ScriptReference/ComputeShader.html GraphicsBuffer.Target ComputeBufferType https://www.udemy.com/course/compute-shaders/ https://github.com/NikLever/UnityComputeShaders youtube: Compute Shaders: Optimize your engine using compute / Lou Kramer, AMD https://catlikecoding.com/unity/tutorials/basics/compute-shaders/ https://www.ronja-tutorials.com/post/050-compute-shader/"
  },
  "docs/steps/01_CS_HelloWorld.html": {
    "href": "docs/steps/01_CS_HelloWorld.html",
    "title": "01_CS_HelloWorld | nf.example.computeshader",
    "summary": "01_CS_HelloWorld https://web.archive.org/web/20160416003055/https://scrawkblog.com/2014/06/26/directcompute-tutorial-for-unity-kernels-and-thread-groups/ #pragma kernel CS_HelloWorld RWStructuredBuffer<int> _Buffer; [numthreads(4, 1, 1)] void CS_HelloWorld(uint3 threadID : SV_GroupThreadID) { _Buffer[threadID.x] = threadID.x; } using UnityEngine; [DisallowMultipleComponent] public sealed class CS_HelloWorld : MonoBehaviour { private static readonly int NAME_ID_BUFFER = Shader.PropertyToID(\"_Buffer\"); [SerializeField] private ComputeShader _shader; private void Awake() { int[] recvData = new int[4]; using (GraphicsBuffer graphicsBuffer = new GraphicsBuffer(GraphicsBuffer.Target.Structured, 4, sizeof(int))) { _shader.SetBuffer(kernelIndex: 0, NAME_ID_BUFFER, graphicsBuffer); graphicsBuffer.SetData(new int[] { 11, 22, 33, 44 }); _shader.Dispatch(kernelIndex: 0, 1, 1, 1); graphicsBuffer.GetData(recvData); for (int i = 0; i < 4; i++) { Debug.Log(recvData[i]); } } } }"
  },
  "docs/steps/02_CS_Dimension2.html": {
    "href": "docs/steps/02_CS_Dimension2.html",
    "title": "02_CS_Dimension2 | nf.example.computeshader",
    "summary": "02_CS_Dimension2 https://web.archive.org/web/20160416003055/https://scrawkblog.com/2014/06/26/directcompute-tutorial-for-unity-kernels-and-thread-groups/ #pragma kernel CS_Dimension2 RWStructuredBuffer<int> _Buffer; [numthreads(2, 2, 1)] void CS_Dimension2(uint3 dispatchID : SV_DispatchThreadID) { uint index = dispatchID.x + dispatchID.y * 6; _Buffer[index] = index; // 0 1 2 3 4 5 // 6 7 8 9 10 11 // 12 13 14 15 16 17 // 18 19 20 21 22 23 } using System.Text; using UnityEngine; [DisallowMultipleComponent] public sealed class CS_Dimension2 : MonoBehaviour { private static readonly int NAME_ID_BUFFER = Shader.PropertyToID(\"_Buffer\"); [SerializeField] private ComputeShader _shader; private void Awake() { int countGroup = (3 * 2 * 1); // .Dispatch(kernelIndex, 3, 2, 1); int countThread = (2 * 2 * 1); // [numthreads(2, 2, 1)] int countDispatched = countGroup * countThread; int[] recvData = new int[countDispatched]; using (GraphicsBuffer graphicsBuffer = new GraphicsBuffer(GraphicsBuffer.Target.Structured, countDispatched, sizeof(int))) { int kernelIndex = _shader.FindKernel(\"CS_Dimension2\"); _shader.SetBuffer(kernelIndex, NAME_ID_BUFFER, graphicsBuffer); graphicsBuffer.SetData(recvData); _shader.Dispatch(kernelIndex, 3, 2, 1); graphicsBuffer.GetData(recvData); StringBuilder sb = new StringBuilder(); for (int y = 0; y < 4; ++y) { for (int x = 0; x < 6; ++x) { int index = y * 6 + x; sb.Append($\" {recvData[index],2}\"); } sb.AppendLine(); } Debug.Log(sb.ToString()); } } }"
  },
  "docs/steps/03_CS_Image.html": {
    "href": "docs/steps/03_CS_Image.html",
    "title": "03_CS_Image | nf.example.computeshader",
    "summary": "03_CS_Image https://web.archive.org/web/20160118230242/http://scrawkblog.com/2014/06/28/directcompute-turorial-for-unity-textures/ #pragma kernel CS_Image RWTexture2D<half4> _RenderTex; [numthreads(8, 8, 1)] void CS_Image(uint2 id : SV_DispatchThreadID) { float width; float height; _RenderTex.GetDimensions(width, height); half2 uv = half2(id.x / width, id.y / height); _RenderTex[id] = half4(uv.x, uv.y, 0, 1); } using UnityEngine; [DisallowMultipleComponent] [RequireComponent(typeof(MeshRenderer))] public sealed class CS_Image : MonoBehaviour { private static readonly int NAME_ID_BASEMAP = Shader.PropertyToID(\"_BaseMap\"); private static readonly int NAME_ID_RENDERTEX = Shader.PropertyToID(\"_RenderTex\"); [SerializeField] private ComputeShader _shader; private RenderTexture _RenderTex; private void Awake() { _RenderTex = new RenderTexture( width: 64, height: 64, depth: 0, format: RenderTextureFormat.ARGB32, readWrite: RenderTextureReadWrite.Linear) { enableRandomWrite = true }; _RenderTex.Create(); MeshRenderer mr = GetComponent<MeshRenderer>(); mr.material.SetTexture(NAME_ID_BASEMAP, _RenderTex); } private void Start() { int kernelIndex = _shader.FindKernel(\"CS_Image\"); _shader.SetTexture(kernelIndex, NAME_ID_RENDERTEX, _RenderTex); _shader.Dispatch(kernelIndex, _RenderTex.width / 8, _RenderTex.height / 8, 1); } private void OnDestroy() { _RenderTex.Release(); } }"
  },
  "docs/steps/04_CS_Append.html": {
    "href": "docs/steps/04_CS_Append.html",
    "title": "04_CS_Append | nf.example.computeshader",
    "summary": "04_CS_Append https://web.archive.org/web/20160408182735/https://scrawkblog.com/2014/08/14/directcompute-tutorial-for-unity-append-buffers/ #pragma kernel CS_Append AppendStructuredBuffer<float3> _AppendBuffer; float _BetweenSize; float _Width; [numthreads(8, 8, 1)] void CS_Append(uint3 id : SV_DispatchThreadID) { float3 pos = id / (_Width - 1); pos = (pos - 0.5) * 2.0 * _BetweenSize; pos.z = 0.0; if (id.x % 2 == 0 && id.y % 2 == 0) { _AppendBuffer.Append(pos); } } using UnityEngine; using UnityEngine.Assertions; [DisallowMultipleComponent] public sealed class CS_Append : MonoBehaviour { private static readonly int NAME_ID_compute_AppendBuffer = Shader.PropertyToID(\"_AppendBuffer\"); private static readonly int NAME_ID_compute_BetweenSize = Shader.PropertyToID(\"_BetweenSize\"); private static readonly int NAME_ID_compute_Width = Shader.PropertyToID(\"_Width\"); private static readonly int NAME_ID_mat_Buffer = Shader.PropertyToID(\"_Buffer\"); private static readonly int NAME_ID_mat_Color = Shader.PropertyToID(\"_Color\"); [SerializeField] private Material _material; [SerializeField] private ComputeShader _appendBufferShader; private const int WIDTH = 32; private const float BETWEEN_SIZE = 0.5f; private GraphicsBuffer _appendBuffer; private GraphicsBuffer _argBuffer; private void Awake() { _appendBuffer = new GraphicsBuffer(GraphicsBuffer.Target.Append, WIDTH * WIDTH, sizeof(float) * 3); _appendBuffer.SetCounterValue(0); _appendBufferShader.SetBuffer(kernelIndex: 0, NAME_ID_compute_AppendBuffer, _appendBuffer); _appendBufferShader.SetFloat(NAME_ID_compute_BetweenSize, BETWEEN_SIZE); _appendBufferShader.SetFloat(NAME_ID_compute_Width, WIDTH); // Dispatch(4, 4, 1) // [numthreads[8, 8, 1] // 1024 x 1024 Size // x, y짝수만 걸러내면 256개가 _appendBuffer에 누적된다. _appendBufferShader.Dispatch(0, WIDTH / 8, WIDTH / 8, 1); int[] args = new int[] { 0, 1, 0, 0 }; _argBuffer = new GraphicsBuffer(GraphicsBuffer.Target.IndirectArguments, 4, sizeof(int)); _argBuffer.SetData(args); // _appendBuffer에 얼마나 들어있는지 _argBuffer[0]에 넣어주는 코드. GraphicsBuffer.CopyCount(_appendBuffer, _argBuffer, 0); _argBuffer.GetData(args); Assert.AreEqual(256, args[0], \"Vertex Count\"); Assert.AreEqual(1, args[1], \"Instance Count\"); Assert.AreEqual(0, args[2], \"Start Vertex\"); Assert.AreEqual(0, args[3], \"Start Instance\"); } private void OnRenderObject() { _material.SetPass(0); _material.SetBuffer(NAME_ID_mat_Buffer, _appendBuffer); _material.SetColor(NAME_ID_mat_Color, Color.red); // _argBuffer : [정점의 개수, 인스턴스의 개수, 시작 정점과 시작 인스턴스] Graphics.DrawProceduralIndirectNow(MeshTopology.Points, _argBuffer, 0); } private void OnDestroy() { _appendBuffer.Release(); _argBuffer.Release(); } }"
  },
  "docs/steps/05_CS_Consume.html": {
    "href": "docs/steps/05_CS_Consume.html",
    "title": "05_CS_Consume | nf.example.computeshader",
    "summary": "05_CS_Consume https://web.archive.org/web/20160408181557/https://scrawkblog.com/2014/09/04/directcompute-tutorial-for-unity-consume-buffers/ #pragma kernel CS_Consume #pragma kernel CS_Append ConsumeStructuredBuffer<float3> _ConsumeBuffer; AppendStructuredBuffer<float3> _AppendBuffer; float _BetweenSize; float _Width; [numthreads(8, 8, 1)] void CS_Consume(uint3 id : SV_DispatchThreadID) { _ConsumeBuffer.Consume(); } [numthreads(8, 8, 1)] void CS_Append(uint3 id : SV_DispatchThreadID) { float3 pos = id / (_Width - 1); pos = (pos - 0.5) * 2.0 * _BetweenSize; pos.z = 0.0; if (id.x % 2 == 0 && id.y % 2 == 0) { _AppendBuffer.Append(pos); } } using UnityEngine; using UnityEngine.Assertions; [DisallowMultipleComponent] public sealed class CS_Consume : MonoBehaviour { private static readonly int NAME_ID_compute_ConsumeBuffer = Shader.PropertyToID(\"_ConsumeBuffer\"); private static readonly int NAME_ID_compute_AppendBuffer = Shader.PropertyToID(\"_AppendBuffer\"); private static readonly int NAME_ID_compute_BetweenSize = Shader.PropertyToID(\"_BetweenSize\"); private static readonly int NAME_ID_compute_Width = Shader.PropertyToID(\"_Width\"); private static readonly int NAME_ID_mat_Buffer = Shader.PropertyToID(\"_Buffer\"); private static readonly int NAME_ID_mat_Color = Shader.PropertyToID(\"_Color\"); [SerializeField] private Material _material; [SerializeField] private ComputeShader _consumeShader; private const int WIDTH = 32; private const float BETWEEN_SIZE = 0.5f; private GraphicsBuffer _appendBuffer; private GraphicsBuffer _argBuffer; private void Awake() { _appendBuffer = new GraphicsBuffer(GraphicsBuffer.Target.Append, WIDTH * WIDTH, sizeof(float) * 3); _appendBuffer.SetCounterValue(0); int kernelConsumedIndex = _consumeShader.FindKernel(\"CS_Consume\"); int kernelAppendIndex = _consumeShader.FindKernel(\"CS_Append\"); _consumeShader.SetBuffer(kernelConsumedIndex, NAME_ID_compute_ConsumeBuffer, _appendBuffer); _consumeShader.SetBuffer(kernelAppendIndex, NAME_ID_compute_AppendBuffer, _appendBuffer); _consumeShader.SetFloat(NAME_ID_compute_BetweenSize, BETWEEN_SIZE); _consumeShader.SetFloat(NAME_ID_compute_Width, WIDTH); // Dispatch(4, 4, 1) // [numthreads[8, 8, 1] // 1024 x 1024 Size // x, y짝수만 걸러내면 256개가 _appendBuffer에 누적된다. _consumeShader.Dispatch(kernelAppendIndex, WIDTH / 8, WIDTH / 8, 1); // Dispatch(1, 1, 1) // [numthreads[8, 8, 1] // 8 x 8 Size // 64(8 * 8)개만큼 _consumeBuffer로 소모시킨다. _consumeShader.Dispatch(kernelConsumedIndex, WIDTH / 8 / 4, WIDTH / 8 / 4, 1); int[] args = new int[] { 0, 1, 0, 0 }; _argBuffer = new GraphicsBuffer(GraphicsBuffer.Target.IndirectArguments, 4, sizeof(int)); _argBuffer.SetData(args); // _appendBuffer에 얼마나 들어있는지 _argBuffer[0]에 넣어주는 코드. GraphicsBuffer.CopyCount(_appendBuffer, _argBuffer, 0); _argBuffer.GetData(args); Assert.AreEqual(256 - 64, args[0], \"Vertex Count\"); Assert.AreEqual(1, args[1], \"Instance Count\"); Assert.AreEqual(0, args[2], \"Start Vertex\"); Assert.AreEqual(0, args[3], \"Start Instance\"); } private void OnRenderObject() { _material.SetPass(0); _material.SetBuffer(NAME_ID_mat_Buffer, _appendBuffer); _material.SetColor(NAME_ID_mat_Color, Color.yellow); // _argBuffer : [정점의 개수, 인스턴스의 개수, 시작 정점과 시작 인스턴스] Graphics.DrawProceduralIndirectNow(MeshTopology.Points, _argBuffer, 0); } private void OnDestroy() { _appendBuffer.Release(); _argBuffer.Release(); } }"
  },
  "docs/steps/06_CS_Counter.html": {
    "href": "docs/steps/06_CS_Counter.html",
    "title": "06_CS_Counter | nf.example.computeshader",
    "summary": "06_CS_Counter #pragma kernel CS_Counter #define THREADS 4 #define GROUPS 1 RWStructuredBuffer<int> _CounterBuffer; [numthreads(THREADS, THREADS, 1)] void CS_Counter(uint3 dispatchID : SV_DispatchThreadID) { uint id = dispatchID.x + dispatchID.y * THREADS * GROUPS; int count = _CounterBuffer.IncrementCounter(); _CounterBuffer[id] = count; } using UnityEngine; [DisallowMultipleComponent] public sealed class CS_Counter : MonoBehaviour { private static readonly int NAME_ID_COUNTERBUFFER = Shader.PropertyToID(\"_CounterBuffer\"); [SerializeField] private ComputeShader _counterShader; void Awake() { int size = 4 * 4 * 1 * 1; using (GraphicsBuffer counterBuffer = new GraphicsBuffer(GraphicsBuffer.Target.Counter, size, sizeof(int))) { counterBuffer.SetCounterValue(0); _counterShader.SetBuffer(0, NAME_ID_COUNTERBUFFER, counterBuffer); _counterShader.Dispatch(0, 1, 1, 1); int[] data = new int[size]; counterBuffer.GetData(data); for (int i = 0; i < data.Length; ++i) { Debug.Log(data[i]); } } } }"
  },
  "index.html": {
    "href": "index.html",
    "title": "",
    "summary": ""
  }
}